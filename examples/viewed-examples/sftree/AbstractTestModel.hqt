#pragma once
#include <string>
#include <string_view>
#include <viewed/forward_types.hpp>

#include <QtCore/QString>
#include <QtCore/QVariant>
#include <QtCore/QAbstractItemModel>


/// this is original entity.
struct test_tree_entity
{
	QString filename;
	std::string sometext;
	int int_value;
};

/// this is compliment node entity, it's type(cpp type) must be different from correspondent leaf entity
struct test_tree_node
{
	QString filename;
	std::string sometext;
	int int_value;
};

/// extracts leaf name from path
inline std::string_view get_name(std::string_view filepath)
{
	int pos = filepath.rfind('/') + 1;
	return filepath.substr(pos);
}

/// extracts leaf name from path
inline QStringRef get_name(QStringRef filepath)
{
	int pos = filepath.lastIndexOf('/') + 1;
	return filepath.mid(pos);
}


class test_tree_sorter
{
	using leaf_type = test_tree_entity;
	using node_type = test_tree_node;

	using path_type = QString;
	using pathview_type = QStringRef;

	using leaf_compare_function = bool(*)(const leaf_type & l1, const leaf_type & l2) noexcept;
	using node_compare_function = bool(*)(const node_type & l1, const node_type & l2) noexcept;

	leaf_compare_function m_leaf_compare = nullptr;
	node_compare_function m_node_compare = nullptr;

	template <class Entity, class Type, Type Entity::*member, class Pred>
	static bool compare_entity(const Entity & e1, const Entity & e2) noexcept;

public:
	void reset(viewed::nosort_type);
	void reset(unsigned type, Qt::SortOrder order);

public:
	inline bool operator()(const node_type & p1, const node_type & p2) const noexcept { return m_node_compare(p1, p2); }
	inline bool operator()(const node_type & p1, const leaf_type & l2) const noexcept { return true; }
	inline bool operator()(const leaf_type & l1, const leaf_type & l2) const noexcept { return m_leaf_compare(l1, l2); }
	inline bool operator()(const leaf_type & l1, const node_type & p2) const noexcept { return false; }

	inline explicit operator bool() const noexcept { return m_leaf_compare; }

public:
	test_tree_sorter() : test_tree_sorter(viewed::nosort) {}
	test_tree_sorter(viewed::nosort_type val) { reset(val); }
	test_tree_sorter(unsigned type, Qt::SortOrder order) { reset(type, order); }
};

class test_tree_filter
{
	using leaf_type = test_tree_entity;
	using node_type = test_tree_node;

	using path_type = QString;
	using pathview_type = QStringRef;

	path_type m_filterStr;

public:
	viewed::refilter_type set_expr(QString expr);

	bool always_matches() const noexcept { return m_filterStr == ""; }
	bool matches(const pathview_type & name) const noexcept;

	inline bool operator()(const pathview_type & name) const noexcept { return matches(name); }
	inline bool operator()(const leaf_type & l) const noexcept { return matches(&l.filename); }
	inline bool operator()(const node_type & p) const noexcept { return matches(&p.filename); }
	inline explicit operator bool() const noexcept { return not always_matches(); }
};



class AbstractTestModel : public QAbstractItemModel
{
	Q_OBJECT;

private:
	using base_type = QAbstractItemModel;

protected:
	std::vector<unsigned> m_columns = {0, 1, 2};

	QString m_filterStr;
	Qt::SortOrder m_sortOrder = Qt::AscendingOrder;
	int m_sortColumn = -1;

protected:
	void SetColumns(std::vector<unsigned> columns);

public:
	// view index - index of qt modelm that column of QModelIndex
	// meta index - index as used in meta
	inline  unsigned ViewToMetaIndex(std::size_t view_index) const { /*assert(view_index < m_columns.size());*/ return m_columns[view_index]; }
	virtual unsigned MetaToViewIndex(unsigned meta_index) const;

protected:
	virtual void FilterBy(QString expr) = 0;
	virtual void SortBy(int column, Qt::SortOrder order) = 0;

public:
	virtual QString FieldName(int section) const;
	virtual QString FieldName(const QModelIndex & index) const;
	virtual QString GetString(const QModelIndex & index) const;
	virtual QString GetStringShort(const QModelIndex & index) const;

public:
	void SetFilter(QString expr);
	auto GetFilter() const noexcept { return m_filterStr; }

	void SetSorting(int column, Qt::SortOrder order = Qt::AscendingOrder) { sort(column, order); }
	auto GetSorting() const noexcept { return std::make_pair(m_sortColumn, m_sortOrder); }

Q_SIGNALS:
	void SortingChanged(int column, Qt::SortOrder order);
	void FilterChanged(QString expr);

public:
	// implemented by derived
	virtual QVariant GetEntity(const QModelIndex & index) const = 0;
	virtual QVariant GetItem(const QModelIndex & index) const = 0;
	virtual int FullRowCount(const QModelIndex & parent = QModelIndex()) const = 0;
	int rowCount(const QModelIndex & parent = QModelIndex()) const override = 0;

public:
	int columnCount(const QModelIndex & parent = QModelIndex()) const override;
	void sort(int column, Qt::SortOrder order = Qt::AscendingOrder) final override;

	// some default implementations with help of GetStringShort / GetFieldName / others
	QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

public:
	using base_type::base_type;
};

/// AbstractItemModel for tables
class AbstractTableTestModel : public AbstractTestModel
{
	Q_OBJECT;

private:
	using base_type = AbstractTestModel;

public:
	Qt::ItemFlags flags(const QModelIndex & index) const override;
	QModelIndex index(int row, int column, const QModelIndex & parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex & child) const override;
	QModelIndex sibling(int row, int column, const QModelIndex & idx) const override;
	bool hasChildren(const QModelIndex & parent) const override;

 private:
	 using base_type::base_type;
};

Q_DECLARE_METATYPE(      test_tree_entity *)
Q_DECLARE_METATYPE(const test_tree_entity *)
Q_DECLARE_METATYPE(      test_tree_node *)
Q_DECLARE_METATYPE(const test_tree_node *)
